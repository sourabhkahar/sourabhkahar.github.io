import{D as p,E as i,G as l,H as c,I as h,J as m,K as g,L as d,M as v,N as n,z as y,O as D,P as A,Q as b,R as q,S as P}from"./index-COr2qVOa.js";const o="artists",_=10;let r=[],f="",a=[],w=null;async function F(t=""){f=t;const s=i(c(n,o),l("deleted_at","==",null),d("name"),d("created_at","desc"),g(t),m(t+""),h(_));a=await p(s),w=a.docs[a.docs.length-1],r=[],r.push(a.docs[0])}async function N(t){const s=i(c(n,o),l("deleted_at","==",null),d("name"),d("created_at","desc"),g(f),m(f+""),q(t),h(_));a=await p(s),r.push(a.docs[0]),w=a.docs[a.docs.length-1]}async function k(){if(r.length===0)return;r.pop();const t=r[r.length-1],s=i(c(n,o),l("deleted_at","==",null),d("name"),d("created_at","desc"),g(f),m(f+""),g(t),h(_));a=await p(s),w=a.docs.at(-1)}async function z(){const t=i(c(n,o),l("deleted_at","==",null));return(await v(t)).data().count}async function B(t){const s=A(n,o,t),e=await b(s);return e.exists()?e.data():{}}async function C(t,s){try{const e={updated_at:y(),...s};return await D(A(n,o,t),e,{merge:!0}),!0}catch{return!1}}async function E(t){try{const s={updated_at:y(),created_at:y(),deleted_at:null,...t};return await P(c(n,o),s,{merge:!0})}catch{return!1}}async function G(){const t=await p(i(c(n,"artists"),l("deleted_at","==",null))),s=[];for(const e of t.docs){const u={id:e.id,...e.data()},S=await R(u.id);s.push({artist:u,services:S})}return s}async function R(t){const s=i(c(n,"artists",t,"services"),l("deleted_at","==",null));return(await p(s)).docs.map(u=>({id:u.id,...u.data()}))}export{k as a,N as b,r as c,a as d,w as e,B as f,G as g,E as h,F as l,_ as p,z as t,C as u};
